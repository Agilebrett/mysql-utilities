# Dump of table test_relay.t1 for server rep_master_gtid:
a,b
1,one
2,two
3,three
4,four
# Dump of table test_relay.t1 for server rep_slave1_gtid:
a,b
1,one
# Dump of table test_relay.t1 for server rep_slave2_gtid:
a,b
1,one
# Dump of table test_relay.t1 for server rep_slave3_gtid:
a,b
1,one
2,two
# Dump of table test_relay.t1 for server rep_slave4_gtid:
a,b
1,one
2,two
3,three
4,four
Test case 1 - failover to 127.0.0.1:PORT2 with relay log entries
WARNING: The --master option is not required for 'failover' (option ignored).
# Checking privileges.
# Checking privileges on candidates.
# Performing failover.
# Checking eligibility of slave 127.0.0.1:PORT2 for candidate.
#   GTID_MODE=ON ... Ok
#   Replication user exists ... Ok
# Candidate slave 127.0.0.1:PORT2 will become the new master.
# Checking slaves status (before failover).
# WARNING: Problem detected with SQL thread for slave '127.0.0.1'@'PORT3' that can result on a unstable topology.
#  - SQL thread running: No
#  - SQL error: None
#  Tip: Check the slave server log to identify the problem and fix it. For more information, see: http://dev.mysql.com/doc/refman/5.6/en/replication-problems.html
# WARNING: Problem detected with SQL thread for slave '127.0.0.1'@'PORT4' that can result on a unstable topology.
#  - SQL thread running: No
#  - SQL error: None
#  Tip: Check the slave server log to identify the problem and fix it. For more information, see: http://dev.mysql.com/doc/refman/5.6/en/replication-problems.html
# Preparing candidate for failover.
# Reading events in relay log for slave 127.0.0.1:PORT3
# No missing transactions found on 127.0.0.1:PORT3. Skipping connection of candidate as slave.
# Reading events in relay log for slave 127.0.0.1:PORT4
# Missing transactions found on 127.0.0.1:PORT4. SELECT gtid_subset() = 0
# LOCK STRING: FLUSH TABLES WITH READ LOCK
# Connecting candidate to 127.0.0.1:PORT4 as a temporary slave to retrieve unprocessed GTIDs.
# Change master command for 127.0.0.1:PORT2
# CHANGE MASTER TO MASTER_HOST = '127.0.0.1', MASTER_USER = 'rpl', MASTER_PASSWORD = 'rpl', MASTER_PORT = PORT4, MASTER_AUTO_POSITION=1
# UNLOCK STRING: UNLOCK TABLES
# Waiting for candidate to catch up to slave 127.0.0.1:PORT4.
# Slave 127.0.0.1:PORT2:
# QUERY = SELECT WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS(XXXXXXXXX)
# Return Code = XXXX
# Reading events in relay log for slave 127.0.0.1:PORT5
# Missing transactions found on 127.0.0.1:PORT5. SELECT gtid_subset() = 0
# LOCK STRING: FLUSH TABLES WITH READ LOCK
# Connecting candidate to 127.0.0.1:PORT5 as a temporary slave to retrieve unprocessed GTIDs.
# Change master command for 127.0.0.1:PORT2
# CHANGE MASTER TO MASTER_HOST = '127.0.0.1', MASTER_USER = 'rpl', MASTER_PASSWORD = 'rpl', MASTER_PORT = PORT5, MASTER_AUTO_POSITION=1
# UNLOCK STRING: UNLOCK TABLES
# Waiting for candidate to catch up to slave 127.0.0.1:PORT5.
# Slave 127.0.0.1:PORT2:
# QUERY = SELECT WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS(XXXXXXXXX)
# Return Code = XXXX
# Creating replication user if it does not exist.
# Stopping slaves.
# Performing STOP on all slaves.
#   Executing stop on slave 127.0.0.1:PORT3 WARN - slave is not configured with this master
#   Executing stop on slave 127.0.0.1:PORT3 Ok
#   Executing stop on slave 127.0.0.1:PORT4 WARN - slave is not configured with this master
#   Executing stop on slave 127.0.0.1:PORT4 Ok
#   Executing stop on slave 127.0.0.1:PORT5 WARN - slave is not configured with this master
#   Executing stop on slave 127.0.0.1:PORT5 Ok
# Switching slaves to new master.
# Change master command for 127.0.0.1:PORT3
# CHANGE MASTER TO MASTER_HOST = '127.0.0.1', MASTER_USER = 'rpl', MASTER_PASSWORD = 'rpl', MASTER_PORT = PORT2, MASTER_AUTO_POSITION=1
# Change master command for 127.0.0.1:PORT4
# CHANGE MASTER TO MASTER_HOST = '127.0.0.1', MASTER_USER = 'rpl', MASTER_PASSWORD = 'rpl', MASTER_PORT = PORT2, MASTER_AUTO_POSITION=1
# Change master command for 127.0.0.1:PORT5
# CHANGE MASTER TO MASTER_HOST = '127.0.0.1', MASTER_USER = 'rpl', MASTER_PASSWORD = 'rpl', MASTER_PORT = PORT2, MASTER_AUTO_POSITION=1
# Disconnecting new master as slave.
# Execute on 127.0.0.1:PORT2: RESET SLAVE ALL
# Starting slaves.
# Performing START on all slaves.
#   Executing start on slave 127.0.0.1:PORT3 Ok
#   Executing start on slave 127.0.0.1:PORT4 Ok
#   Executing start on slave 127.0.0.1:PORT5 Ok
# Checking slaves for errors.
# 127.0.0.1:PORT3 status: Ok 
# 127.0.0.1:PORT4 status: Ok 
# 127.0.0.1:PORT5 status: Ok 
# Failover complete.
# Attempting to contact 127.0.0.1 ... Success
# Attempting to contact 127.0.0.1 ... Success
# Attempting to contact 127.0.0.1 ... Success
# Attempting to contact 127.0.0.1 ... Success
#
# Replication Topology Health:
# ...done.
# Dump of table test_relay.t1 for server rep_master_gtid:
a,b
1,one
2,two
3,three
4,four
# Dump of table test_relay.t1 for server rep_slave1_gtid:
a,b
1,one
2,two
3,three
4,four
# Dump of table test_relay.t1 for server rep_slave2_gtid:
a,b
1,one
2,two
3,three
4,four
# Dump of table test_relay.t1 for server rep_slave3_gtid:
a,b
1,one
2,two
3,three
4,four
# Dump of table test_relay.t1 for server rep_slave4_gtid:
a,b
1,one
2,two
3,three
4,four
Test case 2 - failover to 127.0.0.1:PORT3 with skipping slaves
WARNING: The --master option is not required for 'failover' (option ignored).
# Checking privileges.
# Checking privileges on candidates.
# Performing failover.
# Checking eligibility of slave 127.0.0.1:PORT3 for candidate.
#   GTID_MODE=ON ... Ok
#   Replication user exists ... Ok
# Candidate slave 127.0.0.1:PORT3 will become the new master.
# Checking slaves status (before failover).
# Preparing candidate for failover.
# Reading events in relay log for slave 127.0.0.1:PORT4
# No missing transactions found on 127.0.0.1:PORT4. Skipping connection of candidate as slave.
# No missing transactions found on 127.0.0.1:PORT5. Skipping connection of candidate as slave.
# Creating replication user if it does not exist.
# Stopping slaves.
# Performing STOP on all slaves.
#   Executing stop on slave 127.0.0.1:PORT4 WARN - slave is not configured with this master
#   Executing stop on slave 127.0.0.1:PORT4 Ok
#   Executing stop on slave 127.0.0.1:PORT5 WARN - slave is not configured with this master
#   Executing stop on slave 127.0.0.1:PORT5 Ok
# Switching slaves to new master.
# Change master command for 127.0.0.1:PORT4
# CHANGE MASTER TO MASTER_HOST = '127.0.0.1', MASTER_USER = 'rpl', MASTER_PASSWORD = 'rpl', MASTER_PORT = PORT3, MASTER_AUTO_POSITION=1
# Change master command for 127.0.0.1:PORT5
# CHANGE MASTER TO MASTER_HOST = '127.0.0.1', MASTER_USER = 'rpl', MASTER_PASSWORD = 'rpl', MASTER_PORT = PORT3, MASTER_AUTO_POSITION=1
# Disconnecting new master as slave.
# Execute on 127.0.0.1:PORT3: RESET SLAVE ALL
# Starting slaves.
# Performing START on all slaves.
#   Executing start on slave 127.0.0.1:PORT4 Ok
#   Executing start on slave 127.0.0.1:PORT5 Ok
# Checking slaves for errors.
# 127.0.0.1:PORT4 status: Ok 
# 127.0.0.1:PORT5 status: Ok 
# Failover complete.
# Attempting to contact 127.0.0.1 ... Success
# Attempting to contact 127.0.0.1 ... Success
# Attempting to contact 127.0.0.1 ... Success
#
# Replication Topology Health:
# ...done.
